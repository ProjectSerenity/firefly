# Copyright 2022 The Firefly Authors.
#
# Use of this source code is governed by a BSD 3-clause
# license that can be found in the LICENSE file.

# The bootloader package is a little unusual, as we use
# both its library crate and main binary crate, plus we
# depend on its build.rs script.
#
# The library crate is a standard rust_library.
#
# The build.rs script  produces a modified version of the
# kernel binary. It's not currently possible to declare
# or use output file with a cargo_build_script. Instead,
# we build it as a rust_binary and then use a genrule to
# invoke it, collecting its outputs in the process.
#
# The binary crate is built as a rust_binary, passing in
# the outputs from the build script. This produces the
# bootable image in the form of an ELF executable.

load("@rules_rust//rust:defs.bzl", "rust_binary", "rust_library")

rust_library(
    name = "bootloader",
    srcs = glob(["**/*.rs"]),
    compile_data = glob(["**"]),
    crate_root = "src/lib.rs",
    edition = "2018",
    rustc_flags = [
        # In most cases, warnings in 3rd party crates are not interesting as
        # they're out of the control of consumers. The flag here silences
        # warnings. For more details see:
        # https://doc.rust-lang.org/rustc/lints/levels.html
        "--cap-lints=allow",
    ],
    tags = [
        "manual",
    ],
    visibility = ["//visibility:public"],
)

# Now, the multiple steps necessary to build
# the bootloader binary.
#
# First, we compile the build script.

rust_binary(
    name = "build_script",
    srcs = ["build.rs"],
    crate_root = "build.rs",
    edition = "2021",
    visibility = ["//visibility:public"],
    deps = [
        "//vendor/rust/llvm-tools",
    ],
)

# Invoke the build script, passing
# in the kernel binary and its
# Cargo.toml.

genrule(
    name = "package_kernel",
    srcs = [
        "//kernel",
        "@rust_linux_x86_64//:rustc",
    ],
    outs = [
        "libkernel_bin-kernel.a",
    ],
    cmd = """
        export KERNEL="$(location @//kernel:kernel)"
        export OUT_DIR="$$(realpath $(@D))"
        export PATH="$$(dirname $(location @rust_linux_x86_64//:rustc)):$$PATH"
        $(location :build_script) > /dev/null""",
    message = "Packaging the kernel binary",
    tools = [
        ":build_script",
    ],
    visibility = ["//visibility:private"],
)

# Build the bootloader binary using the
# information and files generated by the
# build script above.
#
# Note, we don't invoke this target directly,
# as it needs to be built for a custom
# target configuration. Instead, we invoke
# bootloader_bin_transition below.

rust_binary(
    name = "bootloader_bin",
    srcs = glob(["**/*.rs"]),
    compile_data = [
        ":libkernel_bin-kernel.a",
    ],
    crate_root = "src/main.rs",
    data = glob(
        ["**"],
        exclude = [
            # These can be manually added with overrides if needed.

            # If you run `cargo build` in this dir, the target dir can get very big very quick.
            "target/**",

            # These are not vendored from the crate - we exclude them to avoid busting caches
            # when we change how we generate BUILD files and such.
            "BUILD.bazel",
            "WORKSPACE.bazel",
            "WORKSPACE",
        ],
    ),
    edition = "2021",
    linker_script = "linker.ld",
    rustc_flags = [
        "--cap-lints=allow",
        "-Cpanic=abort",
        "-Clink-args=-nostartfiles -static -Wl,--gc-sections -Wl,--build-id=none",
        "-Ctarget-feature=+crt-static",
        # :bootloader_build_script adds to the linker's search path
        # but for some reason it doesn't add to the link list, so
        # we do that manually here.
        "-lstatic=kernel_bin-kernel",
    ],
    tags = ["manual"],
    visibility = ["//visibility:public"],
    deps = [
        ":bootloader",
        "//vendor/rust/bit_field",
        "//vendor/rust/fixedvec",
        "//vendor/rust/usize_conversions",
        "//vendor/rust/x86_64",
        "//vendor/rust/xmas-elf",
    ],
)
