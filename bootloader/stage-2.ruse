; Copyright 2024 The Firefly Authors.
;
; Use of this source code is governed by a BSD 3-clause
; license that can be found in the LICENSE file.

(package main)

; This is the second stage of the bootloader, which
; starts in 16-bit real mode, loads the kernel from
; disk, creates an e820 memory map, enters protected
; mode, and jumps to the third stage.

(let stage-2-debug-msg "Booting (second stage)...\r\n")

; stage-2 is the code started by the stage-1 loader,
; once it has copied the rest of the bootloader into
; memory.
;
; We start in 16-bit real mode.
'(arch x86-64)
'(mode 16)
(asm-func (stage-2)
	; Print a debug message.
	(mov cx (len stage-2-debug-msg))
	(mov si (string-pointer stage-2-debug-msg))
	(call (@ real-mode-print))

	; Some BIOS implementations assume that the
	; processor will only operate in Legacy Mode.
	; We change the Target Operating Mode to
	; "Long Mode Target Only" so that the firmware
	; expects each CPU to enter long mode once and
	; then stay in it. This allows the firmware to
	; enable mode-specific optimisations.
	;
	; We save the flags, as CF is set if the callback
	; is not supported (in which case this is a
	; no-op).
	(pushf)
	(mov ax 0xec00)
	(mov bl 0x2)
	(int 0x15)
	(popf)

	; Load the kernel from disk.
	(jmp (@ load-kernel-from-disk)))

; Load the kernel from disk. For more info
; on how this works, see stage 1's function
; load-bootloader-from-disk.
;
; The DAP layout is as follows:
;
; 	Offset   Size  Description
; 	   0      1    Size of packet (16 bytes).
; 	   1      1    Always zero.
; 	   2      2    Number of sectors to transfer (max 127 on some BIOSes).
; 	   4      4    Transfer buffer (16-bit segment:16-bit offset).
; 	   8      4    Lower 32 bits of 48-bit starting LBA.
; 	  12      4    Upper 16 bits of 48-bit starting LBA.
'(arch x86-64)
'(mode 16)
(asm-func (load-kernel-from-disk)
	(xor ecx ecx)                          ; Set the initial offset of zero.
	(mov esi (uint32 data-address-packet)) ; Address of the DAP.
	(mov '(bits 32)(esi) ecx)              ; Zero the first quarter of the packet.
	(mov '(bits 32)(+ esi 4) ecx)          ; Zero the second quarter of the packet.
	(mov '(bits 32)(+ esi 8) ecx )         ; Zero the third quarter of the packet.
	(mov '(bits 32)(+ esi 12) ecx)         ; Zero the fourth quarter of the packet.
	(mov '(bits 8)(esi) 16)                ; Set the DAP packet size.

	; We copy the kernel binary into
	; memory one 512-byte sector at a
	; time, immediately copying the
	; sector to the destination in
	; memory. This is because we can't
	; use BIOS helpers to write to
	; such high address spaces.
	(mov ax (uint16 kernel-copy-buffer))
	(mov (+ esi 4) ax)      ; Set the offset.

	; Set the number of blocks to load.
	(xor eax eax)
	(inc eax)
	(mov (+ esi 2) ax)      ; Set the number of blocks (1).

	; Set the block number to copy from.
	(mov ebx (@ bootloader-end)) ; The start of the kernel.
	(mov eax (ebx))         ; Read the kernel start address.
	(mov ebx (uint32 stage-1-start)) ; The start of the bootloader.
	(sub eax ebx)           ; Set EAX to the disk offset in bytes.
	(shr eax 9)             ; Divide by 512 (block size).
	(mov (+ esi 8) eax)     ; Set the logical block address.

	; Set the destination address we'll
	; copy to (2MiB).
	(mov edi (uint32 kernel-start))

	; In the bootimage tool, we write
	; the length of the kernel binary
	; into the kernel-size symbol.
	;
	; We pull this out of memory and store
	; it in EBP so we can determine when
	; we have copied the whole kernel.
	(mov eax (@ kernel-size))
	(mov ecx (eax))
	(add ecx 511)           ; Align up to whole sectors just in case.
	(shr ecx 9)             ; Divide by 512 (block size).

	'load-from-disk

	; Do the read.
	(mov ah 0x42)           ; Read.
	(int 0x13)
	(jnc 'load-from-disk-ok) ; Continue to the next block.

	; The read failed.
	; Print an error.
	(mov cx (len failed-to-load-kernel))
	(mov si (string-pointer failed-to-load-kernel))
	(call (@ real-mode-print))
	; Exit.
	(mov ax 0x11)
	(out 0xf4 ax)
	; Fallback busy loop.
	'failed-to-load-kernel-loop
	(jmp 'failed-to-load-kernel-loop)

	'load-from-disk-ok

	; Copy block to the 2MiB address.
	(push ecx)
	(push esi)
	(mov ecx (uint32 (/ 512 4))) ; The loaded sector, divide by 4 (32-bit copy in movsd).
	(mov esi (uint32 kernel-copy-buffer))
	; Copy ECX dwords from ESI to EDI.
	(rep movsd (edi) (esi))
	(pop esi)
	(pop ecx)

	; Next block.
	(mov eax (+ esi 8))
	(inc eax)
	(mov (+ esi 8) eax)
	(dec ecx)
	(jnz 'load-from-disk)

	(jmp (@ get-physical-memory-map)))

; The number of entries in the physical memory
; map. We populate this in get-physical-memory-map
; below.
(let memory-physical-map-entries (uint32 0))

; Load the map of physical memory from the BIOS,
; using int 0x15 with EAX 0xe820.
;
; Once we're finished, the number of entries
; will be in memory-physical-map-entries.
;
; Each entry has the following structure:
;
; 	Offset   Size  Description
; 	   0      8    Start address.
; 	   8      8    Length.
; 	  16      4    Region type (only 1 and 3 are useful).
; 	  20      4    ACPI extended attributes (must be 1 beforehand).
;
; The defined region types are:
; - 1: Usable (normal RAM).
; - 2: Reserved (unavailable).
; - 3: ACPI reclaimable memory (usable if cleared).
; - 4: ACPI non-volatile storage (unavailable).
; - 5: Bad memory (unavailable).
;
; The defined ACPI extended attributes are:
; - Bit 0: Present (ignore if unset).
; - Bit 1: Non-volatile (handle with caution).
;
; See http://wiki.osdev.org/Detecting_Memory_(x86).
'(arch x86-64)
'(mode 16)
(asm-func (get-physical-memory-map)
	; Set up our initial register values.
	(mov edi (uint32 physical-memory-map)) ; Destination we write to.
	(xor ebx ebx)         ; EBX must be 0 to start.
	(xor ebp ebp)         ; Keep an entry count in EBP.
	(mov edx 0x0534d4150) ; EDX must be "SMAP".
	(mov eax 0xe820)      ; EAX must be 0xe820.
	(mov '(bytes 4)(+ es di 20) 1) ; Force a valid ACPI 3.X entry by setting the extended attributes to 1.
	(mov ecx 24)          ; Ask for 24 bytes, rather than the older 20-byte scheme.

	; Do the first read.
	(int 0x15)
	(jc 'failed)          ; A carry bit on the first call means the feature is unsupported.

	; Prepare for subsequent reads.
	(mov edx 0x0534d4150) ; Some BIOSes trash this.
	(cmp eax edx)         ; On success, EAX will have been set to "SMAP".
	(jne 'failed)
	(test ebx ebx)        ; If EBX is zero, the list is only 1 entry long and is useless.
	(je 'failed)
	(jmp 'handle-entry)

	'next-read
	(mov eax 0xe820)      ; EAX and ECX get trashed by int 0x15.
	(mov ecx 24)
	(mov '(bytes 4)(+ es di 20) 1) ; Force a valid ACPI 3.X entry by setting the extended attributes to 1.
	(int 0x15)
	(jc 'finished)
	(mov edx 0x0534d4150) ; Some BIOSes trash this.

	'handle-entry
	(jcxz 'skip-entry)    ; Skip any 0-length entries.
	(cmp cl 20)           ; Check whether we got a 24-byte ACPI 3.X response.
	(jbe 'not-extended)
	(test '(bytes 1)(+ es di 20) 1) ; We got an extended response; is the "ignore this entry" bit clear?
	(je 'skip-entry)

	'not-extended
	(mov ecx (+ es di 8)) ; Get the lower 4 bytes of the length.
	(or ecx (+ es di 12)) ; Or with the upper 4 bytes to test for zero.
	(jz 'skip-entry)      ; If the length is zero, skip the entry.

	; We got an entry!
	(inc ebp)               ; Record the entry.
	(add di 24)             ; Move our pointer to the next slot.

	'skip-entry
	(test ebx ebx)          ; If EBX is zero, the list is complete.
	(jne 'next-read)
	(jmp 'finished)

	'failed
	; Print an error.
	(mov cx (len failed-to-load-physical-memory-map))
	(mov si (string-pointer failed-to-load-physical-memory-map))
	(call (@ real-mode-print))
	; Exit.
	(mov ax 0x11)
	(out 0xf4 ax)
	; Fallback busy loop.
	'failed-to-load-physical-memory-map-loop
	(jmp 'failed-to-load-physical-memory-map-loop)

	; All done.
	'finished
	(mov eax (@ memory-physical-map-entries))
	(mov (eax) ebp)       ; Record the number of entries.
	(clc)                 ; Clear the carry flag.
	(jmp (@ enter-protected-mode-again)))

; Enter protected mode for good this time.
; We've done everything we need to in unreal
; mode using the BIOS functions. Now we can
; move on to preparing for long mode.
'(arch x86-64)
'(mode 16)
(asm-func (enter-protected-mode-again)
	; Load the global descriptor table.
	(cli)                 ; Pause interrupts.
	(mov bx (@ global-descriptor-table-32-header))
	(lgdt (bx))

	; Enable and resume protected mode.
	(mov eax cr0)
	(or al 1)             ; Set the protected mode bit.
	(mov cr0 eax)

	; Start stage 3 with a far return.
	(push 0x08)
	(mov eax (@ stage-3))
	(push eax)
	(data32 ret-far))

; This string is printed if we fail to use
; the BIOS's LBA extension to read the kernel
; from disk.
(let failed-to-load-kernel "Boot error: failed to load kernel from disk.\r\n")

; This string is printed if we fail to load
; the map of physical memory from the BIOS.
(let failed-to-load-physical-memory-map "Boot error: failed to load physical mmeory map from BIOS.\r\n")
