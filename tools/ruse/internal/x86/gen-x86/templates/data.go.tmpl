// Code generated by {{ .Command }}; DO NOT EDIT.

// Copyright 2023 The Firefly Authors.
//
// Use of this source code is governed by a BSD 3-clause
// license that can be found in the LICENSE file.

package x86

var ({{ range .Instructions }}
	{{ .UID }} = &Instruction{
		Mnemonic: "{{ .Mnemonic }}",
		UID:      "{{ .UID }}",
		Syntax:   "{{ .Syntax }}",
		Encoding: &Encoding{
			Syntax:            "{{ .Encoding.Syntax }}",{{ if .Encoding.PrefixOpcodes }}
			PrefixOpcodes:     []byte{ {{- range .Encoding.PrefixOpcodes }}{{ printf "%#02x" . }}, {{ end -}} },{{ end }}{{ if .Encoding.NoVEXPrefixes }}
			NoVEXPrefixes:     true,{{ end }}{{ if .Encoding.NoRepPrefixes }}
			NoRepPrefixes:     true,{{ end }}{{ if .Encoding.MandatoryPrefixes }}
			MandatoryPrefixes: []Prefix{ {{- range .Encoding.MandatoryPrefixes }}{{ printf "%#02x" . }}, {{ end -}} },{{ end }}{{ if .Encoding.REX }}
			REX:               true,{{ end }}{{ if .Encoding.REX_R }}
			REX_R:             true,{{ end }}{{ if .Encoding.REX_W }}
			REX_W:             true,{{ end }}{{ if .Encoding.VEX }}
			VEX:               true,{{ end }}{{ if .Encoding.VEX_L }}
			VEX_L:             true,{{ end }}{{ if .Encoding.VEXpp }}
			VEXpp:             {{ .Encoding.VEXpp }},{{ end }}{{ if .Encoding.VEXm_mmmm }}
			VEXm_mmmm:         {{ .Encoding.VEXm_mmmm }},{{ end }}{{ if .Encoding.VEX_W }}
			VEX_W:             true,{{ end }}{{ if .Encoding.VEXis4 }}
			VEXis4:            true,{{ end }}{{ if .Encoding.EVEX }}
			EVEX:              true,{{ end }}{{ if .Encoding.EVEX_Lp }}
			EVEX_Lp:           true,{{ end }}{{ if .Encoding.Mask }}
			Mask:              true,{{ end }}{{ if .Encoding.Zero }}
			Zero:              true,{{ end }}{{ if .Encoding.Rounding }}
			Rounding:          true,{{ end }}{{ if .Encoding.Suppress }}
			Suppress:          true,{{ end }}
			Opcode:            []byte{ {{- range .Encoding.Opcode }}{{ printf "%#02x" . }}, {{ end -}} },{{ if .Encoding.RegisterModifier }}
			RegisterModifier:  {{ .Encoding.RegisterModifier}},{{ end }}{{ if .Encoding.StackIndex }}
			StackIndex:        {{ .Encoding.StackIndex }},{{ end }}{{ if .Encoding.CodeOffset }}
			CodeOffset:        true,{{ end }}{{ if .Encoding.ModRM }}
			ModRM:             true,{{ end }}{{ if .Encoding.ModRMmod }}
			ModRMmod:          {{ .Encoding.ModRMmod }},{{ end }}{{ if .Encoding.ModRMreg }}
			ModRMreg:          {{ .Encoding.ModRMreg }},{{ end }}{{ if .Encoding.ModRMrm }}
			ModRMrm:           {{ .Encoding.ModRMrm }},{{ end }}{{ if .Encoding.SIB }}
			SIB:               true,{{ end }}{{ if .Encoding.ImpliedImmediate }}
			ImpliedImmediate:  []byte{ {{- range .Encoding.ImpliedImmediate }}{{ printf "%#02x" . }}, {{ end -}} },{{ end }}
		},{{ if .Parameters }}
		Parameters: []*Parameter{ {{- range .Parameters }}Param{{ .UID }}, {{ end -}} },{{ end }}
		Mode16: {{ .Mode16 }},
		Mode32: {{ .Mode32 }},
		Mode64: {{ .Mode64 }},{{ if .CPUID }}
		CPUID: []string{ {{- range .CPUID }}"{{ . }}", {{ end -}} },{{ end }}{{ if .OperandSize }}
		OperandSize: true,{{ end }}{{ if .AddressSize }}
		AddressSize: true,{{ end }}{{ if .DataSize }}
		DataSize: {{ .DataSize }},{{ end }}{{ if .Tuple }}
		Tuple:    {{ .Tuple.UID }},{{ end }}
	}{{ end }}
)

var Instructions = []*Instruction{ {{- range .Instructions }}
	{{ .UID }},{{ end }}
}

var InstructionsByUID = map[string]*Instruction{ {{- range .Instructions }}
	"{{ .UID }}": {{ .UID }},{{ end }}
}
